Вопрос 1

В чем разница между областью видимости, продолжительностью и связыванием переменной? Какие область видимости, продолжительность и связывание имеют глобальные переменные?

Технически в C++ все глобальные переменные имеют «область видимости файла», а свойство связывания определяет, могут ли они использоваться в других файлах или нет.

                            Резюме об области видимости
Область видимости идентификатора определяет, где в исходном коде идентификатор может быть доступен.

переменные с областью видимости блока / локальной областью видимости могут быть доступны только в том блоке, в котором они объявлены (включая вложенные блоки). Это включает в себя:
локальные переменные;
параметры функции;
определения пользовательских типов (например, перечисления и классы), объявленные внутри блока;

переменные и функции с глобальной областью видимости / областью видимости файла могут быть доступны в любом месте файла. Это включает в себя:
глобальные переменные;
функции;
определения пользовательских типов (например, перечисления и классы), объявленные внутри пространства имен или в глобальной области видимости.
Резюме о продолжительности

                        Продолжительность переменной определяет, когда она создается и уничтожается.

переменные с автоматической продолжительностью создаются в точке определения и уничтожаются при выходе из блока, частью которого они являются. Например, это:
локальные переменные;
параметры функции;

переменные со статической продолжительностью создаются при запуске программы и уничтожаются при завершении программы. Например, это:
глобальные переменные;
статические локальные переменные;

переменные с динамической продолжительностью создаются и уничтожаются по запросу программиста. Например, это:
динамически создаваемые переменные.

                      Резюме о связывании
Связывание идентификатора определяет, относятся ли несколько объявлений идентификатора к одному и тому же идентификатору или нет.

идентификатор без связывания означает, что идентификатор ссылается только сам на себя. Например:
локальные переменные;
определения пользовательских типов (например, перечисления и классы), объявленные внутри блока;
к идентификатору с внутренним связыванием можно получить доступ в любом месте файла, в котором он объявлен. Например:
статические глобальные переменные (инициализированные или неинициализированные);
статические функции;
константные глобальные переменные;
функции, объявленные внутри безымянного пространства имен;
определения пользовательских типов (таких как перечисления и классы), объявленные внутри безымянного пространства имен;
к идентификатору с внешним связыванием можно получить доступ в любом месте файла, в котором он объявлен, или из других файлов (через предварительное объявление). Например:
функции;
неконстантные глобальные переменные (инициализированные или неинициализированные);
глобальные переменные extern const;
глобальные переменные inline const;
определения пользовательских типов (например, перечисления и классы), объявленные внутри пространства имен или в глобальной области видимости.
Идентификаторы с внешним связыванием обычно вызывают ошибку компоновщика из-за повторяющихся определений, если определения скомпилированы в более чем одном файле .cpp (из-за нарушения правила одного определения). Из этого правила есть некоторые исключения (для типов, шаблонов, встраиваемых функций и переменных) – мы рассмотрим их подробнее в будущих уроках, когда будем говорить об этих темах.

Также обратите внимание, что функции по умолчанию имеют внешнее связывание. Внутренними их можно сделать с помощью ключевого слова static.
